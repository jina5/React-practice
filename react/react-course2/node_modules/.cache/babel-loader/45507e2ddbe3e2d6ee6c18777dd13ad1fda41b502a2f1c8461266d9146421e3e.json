{"ast":null,"code":"var _jsxFileName = \"/Users/jina/Desktop/react/react-course2/src/store/favorite-context.js\",\n  _s = $RefreshSig$();\nimport { createContext, useState } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst FavoritesContext = /*#__PURE__*/createContext({\n  favorites: [],\n  toatalFavorites: 0,\n  addFavorite: favoriteMeetup => {},\n  removeFavorite: meetupId => {},\n  ItemIsFavorite: meetupId => {}\n}); //context생성(초기값)\n\nexport function FavoritesContextProvider(props) {\n  _s();\n  //값을 받으려 하는 모든 컴포넌트에 context전달, context값 업데이트할 수 있음.\n  const [userFavorites, setUserFavorites] = useState([]);\n  function addFavoriteHandler(favortieMeetup) {\n    // setUserFavorites(userFavorites.concat(favoriteMeetup)) //concat : 추가해서 새 배열 변환\n    // 리액트가 스테이트 업데이트 즉시 하지않고 예약을 걸어둔다.\n    // 그래서 이렇게 하면 state를 업데이트 할 때 최신 상태 업데이트를 반영하지 못할 수 있어서, 상태 업데이트 함수를 대신 호출하는게 낫다.\n\n    setUserFavorites(prevUserFavorites => {\n      //함수를 바로 실행, 이전 상태 스냅샷을자동으로 받아옴 (prevUser...)\n      return prevUserFavorites.concat(favortieMeetup); //최신상태 바로 받아올수있음. 정확한 순서대로 실행되기 때문에!\n    });\n  }\n\n  function removeFavoriteHandler(meetupId) {\n    setUserFavorites(prevUserFavorites => {\n      return prevUserFavorites.filter(meetup => meetup.id !== meetupId);\n    });\n  }\n  function itemIsFavoriteHandler(meetupId) {\n    return userFavorites.some(meetup => meetup.id === meetupId);\n  }\n  const context = {\n    favorites: userFavorites,\n    toatalFavorites: userFavorites.length,\n    addFavorite: addFavoriteHandler,\n    removeFavorite: removeFavoriteHandler,\n    itemIsFavorite: itemIsFavoriteHandler\n  };\n  return /*#__PURE__*/_jsxDEV(FavoritesContext.Provider, {\n    value: context,\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 45,\n    columnNumber: 12\n  }, this); //provider:해당 context와 상호작용하는 모든 컴포넌트 포함해야함\n}\n_s(FavoritesContextProvider, \"UlopS2AxBLjN23/y+OKS+T5dH2M=\");\n_c = FavoritesContextProvider;\nexport default FavoritesContext;\nvar _c;\n$RefreshReg$(_c, \"FavoritesContextProvider\");","map":{"version":3,"names":["createContext","useState","FavoritesContext","favorites","toatalFavorites","addFavorite","favoriteMeetup","removeFavorite","meetupId","ItemIsFavorite","FavoritesContextProvider","props","userFavorites","setUserFavorites","addFavoriteHandler","favortieMeetup","prevUserFavorites","concat","removeFavoriteHandler","filter","meetup","id","itemIsFavoriteHandler","some","context","length","itemIsFavorite","children"],"sources":["/Users/jina/Desktop/react/react-course2/src/store/favorite-context.js"],"sourcesContent":["import {createContext, useState} from 'react';\n\nconst FavoritesContext = createContext({\n    favorites : [],\n    toatalFavorites : 0,\n    addFavorite : (favoriteMeetup)=>{},\n    removeFavorite : (meetupId)=>{},\n    ItemIsFavorite : (meetupId)=>{},\n\n}); //context생성(초기값)\n\nexport function FavoritesContextProvider(props){ //값을 받으려 하는 모든 컴포넌트에 context전달, context값 업데이트할 수 있음.\n    const [userFavorites, setUserFavorites] = useState([]);\n\n    function addFavoriteHandler(favortieMeetup){\n        // setUserFavorites(userFavorites.concat(favoriteMeetup)) //concat : 추가해서 새 배열 변환\n        // 리액트가 스테이트 업데이트 즉시 하지않고 예약을 걸어둔다.\n        // 그래서 이렇게 하면 state를 업데이트 할 때 최신 상태 업데이트를 반영하지 못할 수 있어서, 상태 업데이트 함수를 대신 호출하는게 낫다.\n\n        setUserFavorites((prevUserFavorites)=>{ //함수를 바로 실행, 이전 상태 스냅샷을자동으로 받아옴 (prevUser...)\n            return prevUserFavorites.concat(favortieMeetup) //최신상태 바로 받아올수있음. 정확한 순서대로 실행되기 때문에!\n        })\n\n    }\n\n    function removeFavoriteHandler(meetupId) {\n        setUserFavorites(prevUserFavorites => {\n            return prevUserFavorites.filter(meetup => meetup.id !==meetupId)\n        })\n    }\n\n    function itemIsFavoriteHandler(meetupId) {\n        return userFavorites.some(meetup => meetup.id=== meetupId);\n    }\n\n    const context = {\n        favorites : userFavorites,\n        toatalFavorites : userFavorites.length,\n        addFavorite : addFavoriteHandler,\n        removeFavorite : removeFavoriteHandler,\n        itemIsFavorite : itemIsFavoriteHandler\n    };\n\n    \n    return <FavoritesContext.Provider value={context}>\n        {props.children}\n    </FavoritesContext.Provider> //provider:해당 context와 상호작용하는 모든 컴포넌트 포함해야함\n\n}\n\nexport default FavoritesContext;"],"mappings":";;AAAA,SAAQA,aAAa,EAAEC,QAAQ,QAAO,OAAO;AAAC;AAE9C,MAAMC,gBAAgB,gBAAGF,aAAa,CAAC;EACnCG,SAAS,EAAG,EAAE;EACdC,eAAe,EAAG,CAAC;EACnBC,WAAW,EAAIC,cAAc,IAAG,CAAC,CAAC;EAClCC,cAAc,EAAIC,QAAQ,IAAG,CAAC,CAAC;EAC/BC,cAAc,EAAID,QAAQ,IAAG,CAAC;AAElC,CAAC,CAAC,CAAC,CAAC;;AAEJ,OAAO,SAASE,wBAAwB,CAACC,KAAK,EAAC;EAAA;EAAE;EAC7C,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGZ,QAAQ,CAAC,EAAE,CAAC;EAEtD,SAASa,kBAAkB,CAACC,cAAc,EAAC;IACvC;IACA;IACA;;IAEAF,gBAAgB,CAAEG,iBAAiB,IAAG;MAAE;MACpC,OAAOA,iBAAiB,CAACC,MAAM,CAACF,cAAc,CAAC,EAAC;IACpD,CAAC,CAAC;EAEN;;EAEA,SAASG,qBAAqB,CAACV,QAAQ,EAAE;IACrCK,gBAAgB,CAACG,iBAAiB,IAAI;MAClC,OAAOA,iBAAiB,CAACG,MAAM,CAACC,MAAM,IAAIA,MAAM,CAACC,EAAE,KAAIb,QAAQ,CAAC;IACpE,CAAC,CAAC;EACN;EAEA,SAASc,qBAAqB,CAACd,QAAQ,EAAE;IACrC,OAAOI,aAAa,CAACW,IAAI,CAACH,MAAM,IAAIA,MAAM,CAACC,EAAE,KAAIb,QAAQ,CAAC;EAC9D;EAEA,MAAMgB,OAAO,GAAG;IACZrB,SAAS,EAAGS,aAAa;IACzBR,eAAe,EAAGQ,aAAa,CAACa,MAAM;IACtCpB,WAAW,EAAGS,kBAAkB;IAChCP,cAAc,EAAGW,qBAAqB;IACtCQ,cAAc,EAAGJ;EACrB,CAAC;EAGD,oBAAO,QAAC,gBAAgB,CAAC,QAAQ;IAAC,KAAK,EAAEE,OAAQ;IAAA,UAC5Cb,KAAK,CAACgB;EAAQ;IAAA;IAAA;IAAA;EAAA,QACS,EAAC;AAEjC;AAAC,GArCejB,wBAAwB;AAAA,KAAxBA,wBAAwB;AAuCxC,eAAeR,gBAAgB;AAAC;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}